// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protobuf-codegen-pure=3.0.0-pre
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `struct.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct BprmCheckSecurityEventEvent {
    // message fields
    id: ::std::option::Option<::std::string::String>,
    code: ::std::option::Option<::std::string::String>,
    kind: ::std::option::Option<::std::string::String>,
    category: ::std::option::Option<::std::string::String>,
    action: ::std::option::Option<::std::string::String>,
    field_type: ::std::option::Option<::std::string::String>,
    module: ::std::option::Option<::std::string::String>,
    provider: ::std::option::Option<::std::string::String>,
    sequence: ::std::option::Option<u64>,
    ingested: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a BprmCheckSecurityEventEvent {
    fn default() -> &'a BprmCheckSecurityEventEvent {
        <BprmCheckSecurityEventEvent as ::protobuf::Message>::default_instance()
    }
}

impl BprmCheckSecurityEventEvent {
    pub fn new() -> BprmCheckSecurityEventEvent {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string code = 2;

    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 3;

    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string category = 4;

    pub fn get_category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category(&mut self) -> &mut ::std::string::String {
        if self.category.is_none() {
            self.category = ::std::option::Option::Some(::std::string::String::new());
        }
        self.category.as_mut().unwrap()
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        self.category.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string action = 5;

    pub fn get_action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action = ::std::option::Option::Some(::std::string::String::new());
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string field_type = 6;

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module = 7;

    pub fn get_module(&self) -> &str {
        match self.module.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module(&mut self) {
        self.module = ::std::option::Option::None;
    }

    pub fn has_module(&self) -> bool {
        self.module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ::std::string::String) {
        self.module = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut ::std::string::String {
        if self.module.is_none() {
            self.module = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module.as_mut().unwrap()
    }

    // Take field
    pub fn take_module(&mut self) -> ::std::string::String {
        self.module.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string provider = 8;

    pub fn get_provider(&self) -> &str {
        match self.provider.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_provider(&mut self) {
        self.provider = ::std::option::Option::None;
    }

    pub fn has_provider(&self) -> bool {
        self.provider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: ::std::string::String) {
        self.provider = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider(&mut self) -> &mut ::std::string::String {
        if self.provider.is_none() {
            self.provider = ::std::option::Option::Some(::std::string::String::new());
        }
        self.provider.as_mut().unwrap()
    }

    // Take field
    pub fn take_provider(&mut self) -> ::std::string::String {
        self.provider.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 sequence = 9;

    pub fn get_sequence(&self) -> u64 {
        self.sequence.unwrap_or(0)
    }

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint64 ingested = 10;

    pub fn get_ingested(&self) -> u64 {
        self.ingested.unwrap_or(0)
    }

    pub fn clear_ingested(&mut self) {
        self.ingested = ::std::option::Option::None;
    }

    pub fn has_ingested(&self) -> bool {
        self.ingested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingested(&mut self, v: u64) {
        self.ingested = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &BprmCheckSecurityEventEvent| { &m.id },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.id },
            BprmCheckSecurityEventEvent::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "code",
            |m: &BprmCheckSecurityEventEvent| { &m.code },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.code },
            BprmCheckSecurityEventEvent::get_code,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "kind",
            |m: &BprmCheckSecurityEventEvent| { &m.kind },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.kind },
            BprmCheckSecurityEventEvent::get_kind,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "category",
            |m: &BprmCheckSecurityEventEvent| { &m.category },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.category },
            BprmCheckSecurityEventEvent::get_category,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "action",
            |m: &BprmCheckSecurityEventEvent| { &m.action },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.action },
            BprmCheckSecurityEventEvent::get_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "field_type",
            |m: &BprmCheckSecurityEventEvent| { &m.field_type },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.field_type },
            BprmCheckSecurityEventEvent::get_field_type,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "module",
            |m: &BprmCheckSecurityEventEvent| { &m.module },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.module },
            BprmCheckSecurityEventEvent::get_module,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "provider",
            |m: &BprmCheckSecurityEventEvent| { &m.provider },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.provider },
            BprmCheckSecurityEventEvent::get_provider,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "sequence",
            |m: &BprmCheckSecurityEventEvent| { &m.sequence },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.sequence },
            BprmCheckSecurityEventEvent::get_sequence,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "ingested",
            |m: &BprmCheckSecurityEventEvent| { &m.ingested },
            |m: &mut BprmCheckSecurityEventEvent| { &mut m.ingested },
            BprmCheckSecurityEventEvent::get_ingested,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BprmCheckSecurityEventEvent>(
            "BprmCheckSecurityEventEvent",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for BprmCheckSecurityEventEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.category = ::std::option::Option::Some(is.read_string()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(is.read_string()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(is.read_string()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.module = ::std::option::Option::Some(is.read_string()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.provider = ::std::option::Option::Some(is.read_string()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sequence = ::std::option::Option::Some(is.read_uint64()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ingested = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.module.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.provider.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ingested {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.category.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.action.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.field_type.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.module.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.provider.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.sequence {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.ingested {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> BprmCheckSecurityEventEvent {
        BprmCheckSecurityEventEvent::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static BprmCheckSecurityEventEvent {
        static instance: BprmCheckSecurityEventEvent = BprmCheckSecurityEventEvent {
            id: ::std::option::Option::None,
            code: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            category: ::std::option::Option::None,
            action: ::std::option::Option::None,
            field_type: ::std::option::Option::None,
            module: ::std::option::Option::None,
            provider: ::std::option::Option::None,
            sequence: ::std::option::Option::None,
            ingested: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for BprmCheckSecurityEventEvent {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.code = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.category = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.module = ::std::option::Option::None;
        self.provider = ::std::option::Option::None;
        self.sequence = ::std::option::Option::None;
        self.ingested = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BprmCheckSecurityEventEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BprmCheckSecurityEventEvent {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct BprmCheckSecurityEventProcessTarget {
    // message fields
    executable: ::std::option::Option<::std::string::String>,
    args_count: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a BprmCheckSecurityEventProcessTarget {
    fn default() -> &'a BprmCheckSecurityEventProcessTarget {
        <BprmCheckSecurityEventProcessTarget as ::protobuf::Message>::default_instance()
    }
}

impl BprmCheckSecurityEventProcessTarget {
    pub fn new() -> BprmCheckSecurityEventProcessTarget {
        ::std::default::Default::default()
    }

    // optional string executable = 1;

    pub fn get_executable(&self) -> &str {
        match self.executable.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_executable(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_executable(&self) -> bool {
        self.executable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executable(&mut self, v: ::std::string::String) {
        self.executable = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executable(&mut self) -> &mut ::std::string::String {
        if self.executable.is_none() {
            self.executable = ::std::option::Option::Some(::std::string::String::new());
        }
        self.executable.as_mut().unwrap()
    }

    // Take field
    pub fn take_executable(&mut self) -> ::std::string::String {
        self.executable.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 args_count = 2;

    pub fn get_args_count(&self) -> u64 {
        self.args_count.unwrap_or(0)
    }

    pub fn clear_args_count(&mut self) {
        self.args_count = ::std::option::Option::None;
    }

    pub fn has_args_count(&self) -> bool {
        self.args_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_args_count(&mut self, v: u64) {
        self.args_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "executable",
            |m: &BprmCheckSecurityEventProcessTarget| { &m.executable },
            |m: &mut BprmCheckSecurityEventProcessTarget| { &mut m.executable },
            BprmCheckSecurityEventProcessTarget::get_executable,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "args_count",
            |m: &BprmCheckSecurityEventProcessTarget| { &m.args_count },
            |m: &mut BprmCheckSecurityEventProcessTarget| { &mut m.args_count },
            BprmCheckSecurityEventProcessTarget::get_args_count,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BprmCheckSecurityEventProcessTarget>(
            "BprmCheckSecurityEventProcessTarget",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for BprmCheckSecurityEventProcessTarget {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executable = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.args_count = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.executable.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.args_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executable.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.args_count {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> BprmCheckSecurityEventProcessTarget {
        BprmCheckSecurityEventProcessTarget::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static BprmCheckSecurityEventProcessTarget {
        static instance: BprmCheckSecurityEventProcessTarget = BprmCheckSecurityEventProcessTarget {
            executable: ::std::option::Option::None,
            args_count: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for BprmCheckSecurityEventProcessTarget {
    fn clear(&mut self) {
        self.executable = ::std::option::Option::None;
        self.args_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BprmCheckSecurityEventProcessTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BprmCheckSecurityEventProcessTarget {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct BprmCheckSecurityEventProcess {
    // message fields
    pid: ::std::option::Option<u32>,
    entity_id: ::std::option::Option<::std::string::String>,
    name: ::std::option::Option<::std::string::String>,
    ppid: ::std::option::Option<u32>,
    thread_id: ::std::option::Option<u64>,
    pub target: ::protobuf::MessageField<BprmCheckSecurityEventProcessTarget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a BprmCheckSecurityEventProcess {
    fn default() -> &'a BprmCheckSecurityEventProcess {
        <BprmCheckSecurityEventProcess as ::protobuf::Message>::default_instance()
    }
}

impl BprmCheckSecurityEventProcess {
    pub fn new() -> BprmCheckSecurityEventProcess {
        ::std::default::Default::default()
    }

    // optional uint32 pid = 1;

    pub fn get_pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional string entity_id = 2;

    pub fn get_entity_id(&self) -> &str {
        match self.entity_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        if self.entity_id.is_none() {
            self.entity_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entity_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        self.entity_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ppid = 4;

    pub fn get_ppid(&self) -> u32 {
        self.ppid.unwrap_or(0)
    }

    pub fn clear_ppid(&mut self) {
        self.ppid = ::std::option::Option::None;
    }

    pub fn has_ppid(&self) -> bool {
        self.ppid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ppid(&mut self, v: u32) {
        self.ppid = ::std::option::Option::Some(v);
    }

    // optional uint64 thread_id = 5;

    pub fn get_thread_id(&self) -> u64 {
        self.thread_id.unwrap_or(0)
    }

    pub fn clear_thread_id(&mut self) {
        self.thread_id = ::std::option::Option::None;
    }

    pub fn has_thread_id(&self) -> bool {
        self.thread_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thread_id(&mut self, v: u64) {
        self.thread_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "pid",
            |m: &BprmCheckSecurityEventProcess| { &m.pid },
            |m: &mut BprmCheckSecurityEventProcess| { &mut m.pid },
            BprmCheckSecurityEventProcess::get_pid,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "entity_id",
            |m: &BprmCheckSecurityEventProcess| { &m.entity_id },
            |m: &mut BprmCheckSecurityEventProcess| { &mut m.entity_id },
            BprmCheckSecurityEventProcess::get_entity_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "name",
            |m: &BprmCheckSecurityEventProcess| { &m.name },
            |m: &mut BprmCheckSecurityEventProcess| { &mut m.name },
            BprmCheckSecurityEventProcess::get_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "ppid",
            |m: &BprmCheckSecurityEventProcess| { &m.ppid },
            |m: &mut BprmCheckSecurityEventProcess| { &mut m.ppid },
            BprmCheckSecurityEventProcess::get_ppid,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "thread_id",
            |m: &BprmCheckSecurityEventProcess| { &m.thread_id },
            |m: &mut BprmCheckSecurityEventProcess| { &mut m.thread_id },
            BprmCheckSecurityEventProcess::get_thread_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BprmCheckSecurityEventProcessTarget>(
            "target",
            |m: &BprmCheckSecurityEventProcess| { &m.target },
            |m: &mut BprmCheckSecurityEventProcess| { &mut m.target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BprmCheckSecurityEventProcess>(
            "BprmCheckSecurityEventProcess",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for BprmCheckSecurityEventProcess {
    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity_id = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ppid = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.thread_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entity_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ppid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thread_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.entity_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ppid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.thread_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> BprmCheckSecurityEventProcess {
        BprmCheckSecurityEventProcess::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static BprmCheckSecurityEventProcess {
        static instance: BprmCheckSecurityEventProcess = BprmCheckSecurityEventProcess {
            pid: ::std::option::Option::None,
            entity_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            ppid: ::std::option::Option::None,
            thread_id: ::std::option::Option::None,
            target: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for BprmCheckSecurityEventProcess {
    fn clear(&mut self) {
        self.pid = ::std::option::Option::None;
        self.entity_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.ppid = ::std::option::Option::None;
        self.thread_id = ::std::option::Option::None;
        self.target.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BprmCheckSecurityEventProcess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BprmCheckSecurityEventProcess {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct BprmCheckSecurityEventUserGroup {
    // message fields
    id: ::std::option::Option<::std::string::String>,
    name: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a BprmCheckSecurityEventUserGroup {
    fn default() -> &'a BprmCheckSecurityEventUserGroup {
        <BprmCheckSecurityEventUserGroup as ::protobuf::Message>::default_instance()
    }
}

impl BprmCheckSecurityEventUserGroup {
    pub fn new() -> BprmCheckSecurityEventUserGroup {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &BprmCheckSecurityEventUserGroup| { &m.id },
            |m: &mut BprmCheckSecurityEventUserGroup| { &mut m.id },
            BprmCheckSecurityEventUserGroup::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "name",
            |m: &BprmCheckSecurityEventUserGroup| { &m.name },
            |m: &mut BprmCheckSecurityEventUserGroup| { &mut m.name },
            BprmCheckSecurityEventUserGroup::get_name,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BprmCheckSecurityEventUserGroup>(
            "BprmCheckSecurityEventUserGroup",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for BprmCheckSecurityEventUserGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> BprmCheckSecurityEventUserGroup {
        BprmCheckSecurityEventUserGroup::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static BprmCheckSecurityEventUserGroup {
        static instance: BprmCheckSecurityEventUserGroup = BprmCheckSecurityEventUserGroup {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for BprmCheckSecurityEventUserGroup {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BprmCheckSecurityEventUserGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BprmCheckSecurityEventUserGroup {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct BprmCheckSecurityEventUser {
    // message fields
    id: ::std::option::Option<::std::string::String>,
    name: ::std::option::Option<::std::string::String>,
    pub group: ::protobuf::MessageField<BprmCheckSecurityEventUserGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a BprmCheckSecurityEventUser {
    fn default() -> &'a BprmCheckSecurityEventUser {
        <BprmCheckSecurityEventUser as ::protobuf::Message>::default_instance()
    }
}

impl BprmCheckSecurityEventUser {
    pub fn new() -> BprmCheckSecurityEventUser {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "id",
            |m: &BprmCheckSecurityEventUser| { &m.id },
            |m: &mut BprmCheckSecurityEventUser| { &mut m.id },
            BprmCheckSecurityEventUser::get_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "name",
            |m: &BprmCheckSecurityEventUser| { &m.name },
            |m: &mut BprmCheckSecurityEventUser| { &mut m.name },
            BprmCheckSecurityEventUser::get_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BprmCheckSecurityEventUserGroup>(
            "group",
            |m: &BprmCheckSecurityEventUser| { &m.group },
            |m: &mut BprmCheckSecurityEventUser| { &mut m.group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BprmCheckSecurityEventUser>(
            "BprmCheckSecurityEventUser",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for BprmCheckSecurityEventUser {
    fn is_initialized(&self) -> bool {
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.group.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> BprmCheckSecurityEventUser {
        BprmCheckSecurityEventUser::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static BprmCheckSecurityEventUser {
        static instance: BprmCheckSecurityEventUser = BprmCheckSecurityEventUser {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            group: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for BprmCheckSecurityEventUser {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BprmCheckSecurityEventUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BprmCheckSecurityEventUser {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct BprmCheckSecurityEvent {
    // message fields
    timestamp: ::std::option::Option<u64>,
    pub event: ::protobuf::MessageField<BprmCheckSecurityEventEvent>,
    pub process: ::protobuf::MessageField<BprmCheckSecurityEventProcess>,
    pub user: ::protobuf::MessageField<BprmCheckSecurityEventUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a BprmCheckSecurityEvent {
    fn default() -> &'a BprmCheckSecurityEvent {
        <BprmCheckSecurityEvent as ::protobuf::Message>::default_instance()
    }
}

impl BprmCheckSecurityEvent {
    pub fn new() -> BprmCheckSecurityEvent {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 1;

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "timestamp",
            |m: &BprmCheckSecurityEvent| { &m.timestamp },
            |m: &mut BprmCheckSecurityEvent| { &mut m.timestamp },
            BprmCheckSecurityEvent::get_timestamp,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BprmCheckSecurityEventEvent>(
            "event",
            |m: &BprmCheckSecurityEvent| { &m.event },
            |m: &mut BprmCheckSecurityEvent| { &mut m.event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BprmCheckSecurityEventProcess>(
            "process",
            |m: &BprmCheckSecurityEvent| { &m.process },
            |m: &mut BprmCheckSecurityEvent| { &mut m.process },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BprmCheckSecurityEventUser>(
            "user",
            |m: &BprmCheckSecurityEvent| { &m.user },
            |m: &mut BprmCheckSecurityEvent| { &mut m.user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BprmCheckSecurityEvent>(
            "BprmCheckSecurityEvent",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for BprmCheckSecurityEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.process {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.event)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.process)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.process.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> BprmCheckSecurityEvent {
        BprmCheckSecurityEvent::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static BprmCheckSecurityEvent {
        static instance: BprmCheckSecurityEvent = BprmCheckSecurityEvent {
            timestamp: ::std::option::Option::None,
            event: ::protobuf::MessageField::none(),
            process: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for BprmCheckSecurityEvent {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.event.clear();
        self.process.clear();
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BprmCheckSecurityEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BprmCheckSecurityEvent {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cstruct.proto\x12\x0eprobe.protobuf\"\xa5\x02\n\x1bBprmCheckSecurit\
    yEventEvent\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12\x14\n\x04co\
    de\x18\x02\x20\x01(\tR\x04codeB\0\x12\x14\n\x04kind\x18\x03\x20\x01(\tR\
    \x04kindB\0\x12\x1c\n\x08category\x18\x04\x20\x01(\tR\x08categoryB\0\x12\
    \x18\n\x06action\x18\x05\x20\x01(\tR\x06actionB\0\x12\x1a\n\nfield_type\
    \x18\x06\x20\x01(\tR\x04typeB\0\x12\x18\n\x06module\x18\x07\x20\x01(\tR\
    \x06moduleB\0\x12\x1c\n\x08provider\x18\x08\x20\x01(\tR\x08providerB\0\
    \x12\x1c\n\x08sequence\x18\t\x20\x01(\x04R\x08sequenceB\0\x12\x1c\n\x08i\
    ngested\x18\n\x20\x01(\x04R\x08ingestedB\0:\0\"k\n#BprmCheckSecurityEven\
    tProcessTarget\x12\x20\n\nexecutable\x18\x01\x20\x01(\tR\nexecutableB\0\
    \x12\x20\n\nargs_count\x18\x02\x20\x01(\x04R\nargs_countB\0:\0\"\xf0\x01\
    \n\x1dBprmCheckSecurityEventProcess\x12\x12\n\x03pid\x18\x01\x20\x01(\rR\
    \x03pidB\0\x12\x1e\n\tentity_id\x18\x02\x20\x01(\tR\tentity_idB\0\x12\
    \x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12\x14\n\x04ppid\x18\x04\
    \x20\x01(\rR\x04ppidB\0\x12\x1e\n\tthread_id\x18\x05\x20\x01(\x04R\tthre\
    ad.idB\0\x12M\n\x06target\x18\x06\x20\x01(\x0b23.probe.protobuf.BprmChec\
    kSecurityEventProcessTargetR\x06targetB\0:\0\"K\n\x1fBprmCheckSecurityEv\
    entUserGroup\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12\x14\n\x04n\
    ame\x18\x02\x20\x01(\tR\x04nameB\0:\0\"\x8f\x01\n\x1aBprmCheckSecurityEv\
    entUser\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12\x14\n\x04name\
    \x18\x02\x20\x01(\tR\x04nameB\0\x12G\n\x05group\x18\x03\x20\x01(\x0b2/.p\
    robe.protobuf.BprmCheckSecurityEventUserGroupR\x05groupB\0:\0\"\x8d\x02\
    \n\x16BprmCheckSecurityEvent\x12\x1f\n\ttimestamp\x18\x01\x20\x01(\x04R\
    \n@timestampB\0\x12C\n\x05event\x18\x02\x20\x01(\x0b2+.probe.protobuf.Bp\
    rmCheckSecurityEventEventR\x05eventB\0\x12I\n\x07process\x18\x03\x20\x01\
    (\x0b2-.probe.protobuf.BprmCheckSecurityEventProcessR\x07processB\0\x12@\
    \n\x04user\x18\x04\x20\x01(\x0b2*.probe.protobuf.BprmCheckSecurityEventU\
    serR\x04userB\0:\0B\x02H\x01b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(BprmCheckSecurityEventEvent::generated_message_descriptor_data());
        messages.push(BprmCheckSecurityEventProcessTarget::generated_message_descriptor_data());
        messages.push(BprmCheckSecurityEventProcess::generated_message_descriptor_data());
        messages.push(BprmCheckSecurityEventUserGroup::generated_message_descriptor_data());
        messages.push(BprmCheckSecurityEventUser::generated_message_descriptor_data());
        messages.push(BprmCheckSecurityEvent::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
