// Code generated by scripts/generate-structures - DO NOT EDIT.
// to modify, regenerate after modifying templates/userspace.c.j2

#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include "probe.bpf.h"
#include "probe.h"
#include "probe.skel.h"

struct handle_event_wrapper {
  void *ctx;
  void *handler;
};

struct handlers {
  struct handle_event_wrapper *bprm_check_security_handler;
};

struct state {
  struct probe_bpf *obj;
  struct ring_buffer *rb;
  struct handlers *handlers;
  struct bpf_link *bprm_check_security_hook;
};

unsigned long clock_adjustment = 0;

int print_libbpf_log(enum libbpf_print_level lvl, const char *fmt,
                     va_list args) {
  return vfprintf(stderr, fmt, args);
}

int noop_log(enum libbpf_print_level lvl, const char *fmt, va_list args) {
  return 0;
}

// begin bprm_check_security

__attribute__((always_inline)) static int handle_bprm_check_security_event(
    void *ctx, unsigned long ts,
    struct bpf_bprm_check_security_event_t bpf_data) {
  struct handle_event_wrapper *handle = ctx;
  bprm_check_security_event_handler *callback = handle->handler;
  callback(handle->ctx, ts, bpf_data);
  return 0;
}

// end bprm_check_security

static int handle_event(void *ctx, void *data, unsigned long size) {
  unsigned long ts;
  struct bpf_event_t *event = data;
  struct handlers *handlers = ctx;
  switch (event->type) {

  case type_bprm_check_security_event_t:
    ts = (event->bprm_check_security_event_t.__timestamp + clock_adjustment) /
         1000000000l;
    return handle_bprm_check_security_event(
        handlers->bprm_check_security_handler, ts,
        event->bprm_check_security_event_t);
  }
}

void destroy_handlers(struct handlers *h) {
  if (h) {

    if (h->bprm_check_security_handler) {
      free((void *)h->bprm_check_security_handler);
    }

    free((void *)h);
  }
  h = NULL;
}

struct handlers *new_handlers() {
  struct handlers *h = (struct handlers *)malloc(sizeof(struct handlers));
  if (!h) {
    goto cleanup;
  }

  h->bprm_check_security_handler = (struct handle_event_wrapper *)malloc(
      sizeof(struct handle_event_wrapper));
  if (!h->bprm_check_security_handler) {
    goto cleanup;
  }

  goto done;

cleanup:
  destroy_handlers(h);

done:
  return h;
}

struct state *new_state(struct state_configuration config) {
  // figure out clock offsets
  struct timespec boot;
  struct timespec current;
  if (clock_gettime(CLOCK_BOOTTIME, &boot) != 0) {
    // we can't figure out the clock offset, so
    // just return
    return NULL;
  }
  if (clock_gettime(CLOCK_REALTIME, &current) != 0) {
    // we can't figure out the clock offset, so
    // just return
    return NULL;
  }
  unsigned long current_ns = 1000000000 * current.tv_sec + current.tv_nsec;
  unsigned long boot_ns = 1000000000 * boot.tv_sec + boot.tv_nsec;
  clock_adjustment = current_ns - boot_ns;

  if (config.debug) {
    libbpf_set_print(print_libbpf_log);
  } else {
    libbpf_set_print(noop_log);
  }
  struct state *s = (struct state *)malloc(sizeof(struct state));
  if (!s) {
    goto cleanup;
  }
  s->handlers = new_handlers();
  if (!s->handlers) {
    goto cleanup;
  }
  s->obj = NULL;

  s->bprm_check_security_hook = NULL;

  s->obj = probe_bpf__open();
  if (!s->obj) {
    goto cleanup;
  }
  s->obj->rodata->filtered_user = config.filtered_uid;

  if (config.bprm_check_security_handler) {
    s->obj->rodata->bprm_check_security_enabled = 1;
    s->handlers->bprm_check_security_handler->ctx =
        config.bprm_check_security_ctx;
    s->handlers->bprm_check_security_handler->handler =
        config.bprm_check_security_handler;
  }

  if (probe_bpf__load(s->obj)) {
    goto cleanup;
  }

  s->rb = ring_buffer__new(bpf_map__fd(s->obj->maps.events), handle_event,
                           (void *)s->handlers, NULL);
  if (!s->rb) {
    goto cleanup;
  }

  if (config.bprm_check_security_handler) {
    s->bprm_check_security_hook =
        bpf_program__attach_lsm(s->obj->progs.bprm_check_security_hook);
    if (!s->bprm_check_security_hook) {
      goto cleanup;
    }
  }

  goto done;

cleanup:
  destroy_state(s);

done:
  return s;
}

void destroy_state(struct state *s) {
  if (s) {
    if (s->rb) {
      ring_buffer__free(s->rb);
    }

    if (s->bprm_check_security_hook) {
      bpf_link__destroy(s->bprm_check_security_hook);
    }

    if (s->obj) {
      probe_bpf__destroy(s->obj);
    }
    if (s->handlers) {
      destroy_handlers(s->handlers);
    }
    free((void *)s);
  }
  s = NULL;
}

void poll_state(struct state *s, int timeout) {
  if (s->rb) {
    ring_buffer__poll(s->rb, timeout);
  }
}