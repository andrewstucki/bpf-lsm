// Code generated by scripts/generate-structures - DO NOT EDIT.
// to modify, regenerate after modifying templates/userspace.c.j2

#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

#include "probe.h"
#include "probe.skel.h"

struct handle_event_wrapper {
  void *ctx;
  void *handler;
};

struct handlers {
  {% for module in modules -%}
  struct handle_event_wrapper *{{module.name}}_handler;
  {% endfor -%}
};

struct state {
  struct probe_bpf *obj;
  struct ring_buffer *rb;
  struct handlers *handlers;
  {% for module in modules -%}
  struct bpf_link *{{module.name}}_hook;
  {% endfor -%}
  {% for tracepoint in tracepoints -%}
  struct bpf_link *{{tracepoint.hook}}_hook;
  {% endfor -%}
  struct bpf_link *creds_hook;
};

int print_libbpf_log(enum libbpf_print_level lvl, const char *fmt, va_list args) {
  return vfprintf(stderr, fmt, args);
}

int noop_log(enum libbpf_print_level lvl, const char *fmt, va_list args) {
  return 0;
}

{% for module in modules %}
// begin {{module.name}}

{% set entry_point = module.structures | last %}
INLINE_STATIC int handle_{{module.name}}_event(void *ctx, struct bpf_{{entry_point.name}} bpf_data) {
  struct handle_event_wrapper *handle = ctx;
  {{module.name}}_event_handler *callback = handle->handler;
  callback(handle->ctx, bpf_data);
  return 0;
}

// end {{module.name}}
{% endfor %}

static int handle_event(void *ctx, void *data, unsigned long size) {
  struct bpf_event_t *event = data;
  struct handlers *handlers = ctx;
  switch(event->type){
  {% for module in modules %}
  {% set entry_point = module.structures | last %}
    case type_{{ entry_point.name }}:
      return handle_{{module.name}}_event(handlers->{{module.name}}_handler, event->{{entry_point.name}});
  {% endfor %}
  }
  return 0;
}

void destroy_handlers(struct handlers *h) {
  if (h) {
    {% for module in modules %}
    if (h->{{module.name}}_handler) {
      free((void *)h->{{module.name}}_handler);
    }
    {% endfor %}
    free((void *)h);
  }
  h = NULL;
}

struct handlers * new_handlers() {
  struct handlers *h = (struct handlers *)malloc(sizeof(struct handlers));
  if (!h) {
    goto cleanup;
  }
  {% for module in modules %}
  h->{{module.name}}_handler = (struct handle_event_wrapper *)malloc(sizeof(struct handle_event_wrapper));
  if (!h->{{module.name}}_handler) {
    goto cleanup;
  }
  {% endfor %}

  goto done;

cleanup:
  destroy_handlers(h);

done:
  return h;
}

struct state *new_state(struct state_configuration config) {
  // figure out clock offsets
  unsigned long clock_adjustment;
  struct timespec boot;
  struct timespec current;
  if (clock_gettime(CLOCK_BOOTTIME, &boot) != 0) {
    // we can't figure out the clock offset, so
    // just return
    return NULL;
  }
  if (clock_gettime(CLOCK_REALTIME, &current) != 0) {
    // we can't figure out the clock offset, so
    // just return
    return NULL;
  }
  unsigned long current_ns = 1000000000*current.tv_sec + current.tv_nsec;
  unsigned long boot_ns = 1000000000*boot.tv_sec + boot.tv_nsec;
  clock_adjustment = current_ns - boot_ns;

  if (config.debug) {
    libbpf_set_print(print_libbpf_log);
  } else {
    libbpf_set_print(noop_log);
  }
  struct state *s = (struct state *)malloc(sizeof(struct state));
  if (!s) {
    goto cleanup;
  }
  s->handlers = new_handlers();
  if (!s->handlers) {
    goto cleanup;
  }
  s->obj = NULL;
  {% for module in modules %}
  s->{{module.name}}_hook = NULL;
  {% endfor %}
  {% for tracepoint in tracepoints %}
  s->{{tracepoint.hook}}_hook = NULL;
  {% endfor %}
  s->obj = probe_bpf__open();
  if (!s->obj) {
    goto cleanup;
  }
  s->obj->rodata->clock_adjustment = clock_adjustment;
  {% for module in modules %}
  if (config.{{module.name}}_handler) {
    s->handlers->{{module.name}}_handler->ctx = config.{{module.name}}_ctx;
    s->handlers->{{module.name}}_handler->handler = config.{{module.name}}_handler;
  }
  {% endfor %}

  if (probe_bpf__load(s->obj)) {
    goto cleanup;
  }

  s->rb = ring_buffer__new(bpf_map__fd(s->obj->maps.events), handle_event, (void *)s->handlers, NULL);
  if (!s->rb) {
    goto cleanup;
  }

  {% for tracepoint in tracepoints -%}
  s->{{tracepoint.hook}}_hook = bpf_program__attach(s->obj->progs.{{tracepoint.hook}}_hook);
  if (!s->{{tracepoint.hook}}_hook) {
    goto cleanup;
  }
  {% endfor -%}

  {% for module in modules %}
  if (config.{{module.name}}_handler) {
    s->{{module.name}}_hook = bpf_program__attach(s->obj->progs.{{module.name}}_hook);
    if (!s->{{module.name}}_hook) {
      goto cleanup;
    }
  }
  {% endfor %}

  goto done;

cleanup:
  destroy_state(s);
  s = NULL;

done:
  return s;
}

void destroy_state(struct state *s) {
  if (s) {
    if (s->rb) {
      ring_buffer__free(s->rb);
    }
    {% for tracepoint in tracepoints -%}
    if (s->{{tracepoint.hook}}_hook) {
      bpf_link__destroy(s->{{tracepoint.hook}}_hook);
    }
    {% endfor -%}
    {% for module in modules %}
    if (s->{{module.name}}_hook) {
      bpf_link__destroy(s->{{module.name}}_hook);
    }
    {% endfor %}
    if (s->obj) {
      probe_bpf__destroy(s->obj);
    }
    if (s->handlers) {
      destroy_handlers(s->handlers);
    }
    free((void *)s);
  }
  s = NULL;
}

void poll_state(struct state *s, int timeout) {
  if (s->rb) {
    ring_buffer__poll(s->rb, timeout);
  }
}

void set_process_path(struct state *s, pid_t pid, const char *file_path) {
  struct cached_process cached = {};
  strncpy(cached.executable, file_path, sizeof(cached.executable));
  bpf_map_update_elem(bpf_map__fd(s->obj->maps.processes), &pid, &cached, BPF_ANY);
}

{% for module in modules -%}
{% set entry_point = module.structures | last %}
{% if entry_point.queryable -%}
static unsigned int {{module.name}}_rejections_size = 0;
static unsigned int {{module.name}}_filters_size = 0;

void flush_{{module.name}}_rejection_rule(struct state *s, struct query_bpf_{{entry_point.name}} rule) {
  	bpf_map_update_elem(bpf_map__fd(s->obj->maps.{{module.name}}_rejections), &{{module.name}}_rejections_size, &rule, BPF_ANY);
    {{module.name}}_rejections_size++;
    unsigned int index = {{module.name}}_index;
  	bpf_map_update_elem(bpf_map__fd(s->obj->maps.rejection_rule_sizes), &index, &{{module.name}}_rejections_size, BPF_ANY);
}

void flush_{{module.name}}_filter_rule(struct state *s, struct query_bpf_{{entry_point.name}} rule) {
  	bpf_map_update_elem(bpf_map__fd(s->obj->maps.{{module.name}}_filters), &{{module.name}}_filters_size, &rule, BPF_ANY);
    {{module.name}}_filters_size++;
    unsigned int index = {{module.name}}_index;
  	bpf_map_update_elem(bpf_map__fd(s->obj->maps.filter_rule_sizes), &index, &{{module.name}}_filters_size, BPF_ANY);
}
{%endif%}
{%- endfor %}
