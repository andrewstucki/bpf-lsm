#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused_imports)]

extern crate protobuf;

use std::fmt;
use std::os::raw::c_int;
use std::panic;
use std::error;
use std::fmt::Debug;
use log::{debug, warn, error};
use std::sync::Mutex;
use users::{Groups, Users, UsersCache};
use once_cell::sync::Lazy;

use protobuf::json::{PrintError, print_to_string};
use protobuf::{ProtobufError, Message};
use machine_uid;
use sha2::Digest;
use sysinfo::{System, SystemExt};
use pnet::datalink::interfaces;

mod struct_pb;
mod compiler;

pub use compiler::*;
pub use struct_pb::*;

static USERS_CACHE: Lazy<Mutex<UsersCache>> = Lazy::new(|| Mutex::new(UsersCache::new()));

pub mod ffi {
    use super::compiler::*;
    use std::os::raw::{c_char, c_int, c_uint, c_void};

    {% for module in modules %}
    // begin {{module.name}}

    {% for structure in module.structures -%}
    {% if not structure.enrichment -%}
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct {{structure.name}}{% if structure.lifetime %}<'a>{% endif %} {
      {% for field in structure.fields -%}
      {% if not field.enrichment %}pub {{field.name}}: {% if field.type.size is not none %}[{{field.type.rust}}; {{field.type.size}}]{% else %}{{field.type.rust}}{% endif %}{% if field.type.lifetime %}<'a>{%endif%},
      {% endif -%}
      {%- endfor -%}
    }
    {% endif %}
    {% endfor %}

    {% set entry_point = module.structures | last %}
    pub type {{module.name}}_event_handler = extern "C" fn(ctx: *mut c_void, e: {{entry_point.name}});

    {% endfor %}

    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct state_configuration {
      pub debug: bool,
      {% for module in modules -%}
      pub {{module.name}}_ctx: *mut c_void,
      pub {{module.name}}_handler: {{module.name}}_event_handler,
      {% endfor %}
    }
    pub enum state {}
    extern "C" {
        pub fn new_state(config: state_configuration) -> *mut state;
        pub fn poll_state(_self: *mut state, timeout: c_int);
        pub fn destroy_state(_self: *mut state);
        {% for module in modules -%}
        {% set entry_point = module.structures | last %}
        {% if entry_point.queryable -%}
        pub fn flush_{{module.name}}_filter_rule(_self: *mut state, rule: query_bpf_{{entry_point.name}});
        pub fn flush_{{module.name}}_rejection_rule(_self: *mut state, rule: query_bpf_{{entry_point.name}});
        {%endif%}
      {% endfor %}   
    }

    /// Unpack a Rust closure, extracting a `void*` pointer to the data and a
    /// trampoline function which can be used to invoke it.
    ///
    /// # Safety
    ///
    /// It is the user's responsibility to ensure the closure outlives the returned
    /// `void*` pointer.
    ///
    /// Calling the trampoline function with anything except the `void*` pointer
    /// will result in *Undefined Behaviour*.
    ///
    /// The closure should guarantee that it never panics, seeing as panicking
    /// across the FFI barrier is *Undefined Behaviour*. You may find
    /// `std::panic::catch_unwind()` useful.
    {% for module in modules -%}
    {% set entry_point = module.structures | last %}
    pub unsafe fn unpack_{{module.name}}_closure<F>(closure: &mut F) -> (*mut c_void, {{module.name}}_event_handler)
    where
        F: FnMut({{entry_point.name}}),
    {
        extern "C" fn trampoline<F>(data: *mut c_void, e: {{entry_point.name}})
        where
            F: FnMut({{entry_point.name}}),
        {
            let closure: &mut F = unsafe { &mut *(data as *mut F) };
            (*closure)(e);
        }

        (closure as *mut F as *mut c_void, trampoline::<F>)
    }
    {% endfor %}
}

#[derive(Debug, Clone)]
pub enum Error {
    InitializationError,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Error::InitializationError => f.write_str(
                "Could not initialize BPF object, ensure you're using Linux kernel >= 4.18",
            ),
        }
    }
}

use std::ffi::CStr;
use std::os::raw::c_char;
fn transform_string(val: Vec<c_char>) -> String {
  unsafe { CStr::from_ptr(val.as_ptr()).to_string_lossy().into_owned() }
}

fn convert_string_array<T>(size: u64, arr: Vec<T>) -> Vec<String>
where T: Into<Vec<c_char>> + Copy {
    unsafe { 
        let mut strings = vec![];
        for x in 0..size {
            let ptr: Vec<c_char> = arr[x as usize].into();
            let var = CStr::from_ptr(ptr.as_ptr());
            let printable = var.to_string_lossy().into_owned();
            strings.push(printable)
        }
        strings
    }
}

fn int_to_string(v: u32) -> String {
  v.to_string()
}

pub struct Probe<'a> {
    ctx: Option<*mut ffi::state>,
    // store the closures so that we make sure it has
    // the same lifetime as the state wrapper
    {% for module in modules -%}
    {% set entry_point = module.structures | last %}
    _{{module.name}}_handler: Option<Box<dyn 'a + Fn(ffi::{{entry_point.name}})>>,
    {% endfor %}
    debug: bool,
}

#[derive(Debug)]
pub enum SerializationError {
    Json(PrintError),
    Bytes(ProtobufError),
    Transform(String),
}

impl fmt::Display for SerializationError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
          Self::Json(_e) => write!(f, "json serialization failed"),
          Self::Bytes(e) => std::fmt::Display::fmt(&e, f),
          Self::Transform(e) => std::fmt::Display::fmt(&e, f),
        }
    }
}

impl error::Error for SerializationError {
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        match self {
          Self::Json(_) => None,
          Self::Bytes(e) => Some(e),
          Self::Transform(_) => None,
        }
    }
}


pub type SerializableResult<T> = Result<T, SerializationError>;
pub trait SerializableEvent {
    fn to_json(&self) -> SerializableResult<String>;
    fn to_bytes(&self) -> SerializableResult<Vec<u8>>;
    fn enrich_common<'a>(&'a mut self) -> SerializableResult<&'a mut Self>;
    fn update_id(&mut self, id: &mut str);
    fn update_sequence(&mut self, seq: u64);
    fn suffix(&self) -> &'static str;
}

{% for module in modules -%}
{% for structure in module.structures -%}
{%- if not structure.enrichment -%}
impl From<ffi::{{structure.name}}{% if structure.lifetime %}<'_>{%endif%}> for {{structure.final}} {
    fn from(e: ffi::{{structure.name}}) -> Self {
        let mut event = Self::default();
        {%- for field in structure.fields -%}
        {%- if field.complex -%}
        {%- if not field.enrichment -%}
        event.{{field.final}} = Some(e.{{field.name}}.into()).into();
        {%- else -%}
        event.{{field.final}} = Some(Default::default()).into();
        {%- endif -%}
        {%- elif not field.enrichment -%}
        {%- if field.type.transformation.method -%}
        event.{% if field.type.setter %}{{field.type.setter}}{%else%}set_{{field.final}}{%endif%}({{field.type.transformation.method}}({%if field.type.transformation.extra%}{{field.type.transformation.extra}}, {%endif%}e.{{field.name}}.into()));
        {%- else -%}
        event.set_{{field.final}}(e.{{field.name}});
        {%- endif -%}
        {%- endif -%}
        {% endfor -%}
        event
    }
}
{% endif %}
{% endfor %}

{% set entry_point = module.structures | last %}
impl SerializableEvent for {{entry_point.final}} {
    fn to_json(&self) -> SerializableResult<String> {
        match print_to_string(self) {
            Ok(result) => Ok(result),
            Err(e) => Err(SerializationError::Json(e)),
        }
    }

    fn to_bytes(&self) -> SerializableResult<Vec<u8>> {
        let mut event = Event::new();
        event.{{entry_point.name}} = Some(self.clone()).into();
        event.set_event_type(event::EventType::{{entry_point.final | upper}});
        match event.write_to_bytes() {
          Ok(result) => Ok(result),
          Err(e) => Err(SerializationError::Bytes(e)),
        }
    }

    fn update_id(&mut self, id: &mut str) {
      self.event.as_mut().and_then(|e| {
        e.set_id(id.to_string().to_owned());
        Some(e)
      });
    }

    fn update_sequence(&mut self, seq: u64) {
      self.event.as_mut().and_then(|e| {
        e.set_sequence(seq);
        Some(e)
      });
    }

    fn suffix(&self) -> &'static str {
        "{{module.name}}"
    }

    fn enrich_common<'a>(&'a mut self) -> SerializableResult<&'a mut Self> {        
        {
            let cache = USERS_CACHE.lock().unwrap();
            // real enrichments
            let user = self.user.get_mut_ref();
            let uid = user.get_id().parse::<u32>().unwrap();
            let group = user.group.get_mut_ref();
            let gid = group.get_id().parse::<u32>().unwrap();

            for enriched_group in cache.get_group_by_gid(gid) {
                group.set_name(enriched_group.name().to_string_lossy().to_string());
            }
            for enriched_user in cache.get_user_by_uid(uid) {
                user.set_name(enriched_user.name().to_string_lossy().to_string());
            }

            // effective enrichments
            let effective_user = user.effective.get_mut_ref();
            let effective_uid = effective_user.get_id().parse::<u32>().unwrap();
            let effective_group = effective_user.group.get_mut_ref();
            let effective_gid = effective_group.get_id().parse::<u32>().unwrap();
            for enriched_group in cache.get_group_by_gid(effective_gid) {
                effective_group.set_name(enriched_group.name().to_string_lossy().to_string());
            }
            for enriched_user in cache.get_user_by_uid(effective_uid) {
                effective_user.set_name(enriched_user.name().to_string_lossy().to_string());
            }
        }

        // entity id enrichments
        let machine_id = machine_uid::get().unwrap(); // this should probably be error checked

        let process = self.process.get_mut_ref();
        let pid = process.get_pid();
        let process_start = process.get_start();
        let process_entity_id = format!("{}{}{}", machine_id, format!("{:01$}", pid, 5), process_start);  
        
        process.set_entity_id(format!("{:x}", sha2::Sha256::digest(process_entity_id.as_bytes())));

        let parent = process.parent.get_mut_ref();
        let ppid = parent.get_pid();
        let parent_start = parent.get_start();
        let parent_entity_id = format!("{}{}{}", machine_id, format!("{:01$}", ppid, 5), parent_start);  

        parent.set_entity_id(format!("{:x}", sha2::Sha256::digest(parent_entity_id.as_bytes())));


        // We want everything except disks.
        let system = System::new();

        let host = self.host.get_mut_ref();
        host.set_uptime(system.get_uptime());
        for hostname in system.get_host_name() {
           host.set_hostname(hostname);
        }
        let all_interfaces = interfaces();
        let active_interfaces = all_interfaces.iter().filter(|e| e.is_up() && !e.is_loopback() && !e.ips.is_empty());
        for interface in active_interfaces {
            if interface.mac.is_some() {
                host.mac.push(interface.mac.unwrap().to_string());
            }
            for ip in &interface.ips {
                host.ip.push(ip.ip().to_string());
            }
        }
        host.os = Some(Default::default()).into();

        let os = host.os.get_mut_ref();
        os.set_field_type("linux".to_string());
        for os_name in system.get_name() {
          os.set_name(os_name);
        }        
        for kernel_version in system.get_kernel_version() {
          os.set_kernel(kernel_version);
        }        
        
        Ok(self)
    }
}
{% endfor %}

pub trait ProbeHandler<U> {
  fn enqueue<T>(&self, event: &mut T) -> Result<(), U> where T: SerializableEvent + std::fmt::Debug;
}

pub trait TransformationHandler {
  {% for module in modules -%}
  {% set entry_point = module.structures | last %}
  fn enrich_{{module.name}}<'a>(&self, e: &'a mut {{entry_point.final}}) -> SerializableResult<&'a mut {{entry_point.final}}>;
  {% endfor %}
}

pub struct Transformer<T> {
    handler: T,
}

impl<T: TransformationHandler> Transformer<T> {
  pub fn new(handler: T) -> Self {
      Self {
          handler: handler,
      }
  }

  pub fn transform(&self, data: Vec<u8>) -> SerializableResult<String> {
      let e = Event::parse_from_bytes(&data).unwrap();
      match e.get_event_type() {
          {% for module in modules -%}
          {% set entry_point = module.structures | last %}
          event::EventType::{{entry_point.final | upper}} => {
              self.handler.enrich_{{module.name}}((&mut e.{{entry_point.name}}.unwrap()).enrich_common()?)?.to_json()
          },
          {% endfor %}
      }
  }  
}

impl<'a> Probe<'a> {
    pub fn new() -> Self {
        Self {
            ctx: None,
            {% for module in modules -%}
            _{{module.name}}_handler: None,
            {% endfor %}
            debug: false,
        }
    }

    pub fn apply(&mut self, rules: Vec<&str>) -> Result<(), String> {
        for rule in &rules {
            let compiled = rule_compiler::compile(rule)?;
            let query_writer = &BpfQueryWriterFactory::new(self);
            compiled.encode(query_writer)?
        } 
        Ok(())
    }

    pub fn debug(&mut self, debug: bool) -> &mut Self {
      self.debug = debug;
      self
    }

    pub fn run<F: 'a, U>(&mut self, handler: F) -> Result<&mut Self, Error>
    where
        F: 'a + ProbeHandler<U> + panic::RefUnwindSafe,
        U: std::fmt::Display
    {
        {% for module in modules -%}
        {% set entry_point = module.structures | last %}
        let mut {{module.name}}_wrapper = move |e: ffi::{{entry_point.name}}| {
            let result = panic::catch_unwind(|| {
                handler.enqueue(&mut {{entry_point.final}}::from(e))
                    .unwrap_or_else(|e| warn!("error enqueuing data: {}", e));
            });
            if result.is_err() {
              debug!("panic while handling event");
            }
        };
        let ({{module.name}}_closure, {{module.name}}_callback) = unsafe { ffi::unpack_{{module.name}}_closure(&mut {{module.name}}_wrapper) };
        {% endfor %}
  
        let state_config = ffi::state_configuration {
          debug: self.debug,
          {% for module in modules -%}
          {{module.name}}_ctx: {{module.name}}_closure,
          {{module.name}}_handler: {{module.name}}_callback,
          {% endfor %}
        };
        let state = unsafe { ffi::new_state(state_config) };
        if state.is_null() {
            return Err(Error::InitializationError);
        }
        self.ctx = Some(state);
        {% for module in modules -%}
        self._{{module.name}}_handler = Some(Box::new({{module.name}}_wrapper));
        {% endfor %}
        Ok(self)
    }

    pub fn apply_rule<T: QueryStruct>(&self, module: String, operation: rule_compiler::Operation, rule: T) {
        match self.ctx {
            Some(ctx) => match (module.as_str(), operation) {
                {% for module in modules %}
                {% set entry_point = module.structures | last %}
                {% if entry_point.queryable -%}
                ("{{module.name}}", rule_compiler::Operation::Filter) => unsafe { 
                    ffi::flush_{{module.name}}_filter_rule(ctx, std::mem::transmute_copy(&rule));
                },
                ("{{module.name}}", rule_compiler::Operation::Reject) => unsafe { 
                    ffi::flush_{{module.name}}_rejection_rule(ctx, std::mem::transmute_copy(&rule));
                },
                {% endif %}
                {%endfor%}
                _ => return,
            },
            _ => return,
        }
    }

    pub fn poll(&self, timeout: i32) {
        match self.ctx {
            Some(ctx) => unsafe { ffi::poll_state(ctx, timeout as c_int) },
            _ => return,
        }
    }
}

impl<'a> Drop for Probe<'a> {
    fn drop(&mut self) {
        match self.ctx {
            Some(ctx) => unsafe { ffi::destroy_state(ctx) },
            _ => return,
        }
    }
}
