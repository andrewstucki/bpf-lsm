// Code generated by scripts/generate-structures - DO NOT EDIT.
// to modify, regenerate after modifying templates/probe.bpf.h.j2

#ifndef __PROBE_BPF_H
#define __PROBE_BPF_H

{% for module in modules %}
// begin {{module.name}}

#define {{module.name}}_index {{ loop.index0 }}

{% for structure in module.structures -%}
{% if not structure.enrichment -%}
struct bpf_{{structure.name}} {
  {% for field in structure.fields -%}
  {% if not field.enrichment %}{% if field.complex %}struct bpf_{% endif %}{%if field.type.name.type %}{{field.type.name.type}}{% else %}{{field.type.name}}{% endif %} {{field.name}}{%if field.type.name.suffix %}{{field.type.name.suffix}}{% elif field.type.size is not none %}[{{field.type.size}}]{% endif %};
  {% endif -%}
  {%- endfor -%}
};
{% endif -%}

{% if structure.queryable -%}
struct query_bpf_{{structure.name}} {
  {% set entry_point = module.structures | last %}
  {% if entry_point.name == structure.name %}
  char ___absolute;
  {% endif %}
  {% for field in structure.fields -%}
  {% if field.queryable %}
    {% if not field.complex %}char {{field.name}}___operator;{% endif %}
    {% if field.complex %}struct query_bpf_{% endif %}{%if field.type.name.type %}{{field.type.name.type}}{% else %}{{field.type.name}}{% endif %} {{field.name}}{%if field.type.name.suffix %}{{field.type.name.suffix}}{% elif field.type.size is not none %}[{{field.type.size}}]{% endif %};
  {% endif -%}
  {%- endfor -%}
};
{% endif -%}
{% endfor -%}

// end {{module.name}}
{% endfor -%}

enum event_type {
  {% for module in modules %}
  {% set entry_point = module.structures | last %}
  type_{{ entry_point.name }},
  {% endfor %}
}; 

struct bpf_event_t {
  enum event_type type;
  union {
    {% for module in modules %}
    {% set entry_point = module.structures | last %}
    struct bpf_{{entry_point.name}} {{entry_point.name}};
    {% endfor %}
  };
};

{% for tracepoint in tracepoints %}
struct tp_{{tracepoint.hook}}_event {
  {% for field in tracepoint.fields -%}
  {{field}};
  {%- endfor -%}
};
{% endfor %}

#ifdef BPF
#ifndef EPERM
#define EPERM 1
#endif

#define RINGBUFFER_FLAGS 0

#ifndef memset
#define memset(dest, chr, n) __builtin_memset((dest), (chr), (n))
#endif

#ifndef memcpy
#define memcpy(dest, src, n) __builtin_memcpy((dest), (src), (n))
#endif

#ifndef memmove
#define memmove(dest, src, n) __builtin_memmove((dest), (src), (n))
#endif

#define SET_STRING(dest, src)                                                  \
  memcpy(dest, src, (sizeof(src) / sizeof(src[0]) + 1))

// rules checks
#define MAX_RULE_SIZE 8
#define TRUE_ABSOLUTE 1
#define FALSE_ABSOLUTE 2
#define EQUAL_OPERATOR 1
#define NOT_EQUAL_OPERATOR 2
#define NUMBER_EQUALITY(first, second) first == second;
#define NUMBER_INEQUALITY(first, second) first != second;
// TODO
#define STRING_EQUALITY(first, second) false
#define STRING_INEQUALITY(first, second) false

#define TRACEPOINT(family, module, arg)                                        \
  __attribute__((always_inline)) static int ____##module(                      \
      struct tp_##module##_event *event, arg);                                 \
  SEC("tp/" #family "/" #module)                                       \
  int module##_hook(void *ctx) {                                               \
    pid_t pid = (pid_t)bpf_get_current_pid_tgid();                             \
    if (bpf_map_update_elem(&module##_events, &pid, &empty_##module##_event,   \
                            BPF_NOEXIST))                                      \
      return 0;                                                                \
    struct tp_##module##_event *event =                                        \
        bpf_map_lookup_elem(&module##_events, &pid);                           \
    if (!event)                                                                \
      return 0;                                                                \
    return ____##module(event, ctx);                                           \
  }                                                                            \
  static int ____##module(struct tp_##module##_event *event, arg)

#define LSM_HOOK(module, prefix, args...)                                      \
  __attribute__((always_inline)) static int ____##module(                      \
      unsigned long long *ctx, ##args, struct bpf_##module##_event_t *event,   \
      struct task_struct *current_task);                                       \
  SEC("lsm/" #module)                                                          \
  int BPF_PROG(module##_hook, ##args) {                                        \
    if (module##_enabled == 0) {                                               \
      return 0;                                                                \
    }                                                                          \
    struct bpf_event_t *event = bpf_ringbuf_reserve(                           \
        &events, sizeof(struct bpf_event_t), RINGBUFFER_FLAGS);                \
    if (event)                                                                 \
      event->type = type_##module##_event_t;                                   \
    int __ret = 0;                                                             \
    _Pragma("GCC diagnostic push")                                             \
        _Pragma("GCC diagnostic ignored \"-Wint-conversion\"") if (event) {    \
      struct task_struct *current_task =                                       \
          (struct task_struct *)bpf_get_current_task();                        \
                                                                               \
      event->module##_event_t.__timestamp =                                    \
          adjust_timestamp(bpf_ktime_get_boot_ns());                           \
                                                                               \
      event->module##_event_t.process.pid = BPF_CORE_READ(current_task, pid);  \
      event->module##_event_t.process.thread__id =                             \
          BPF_CORE_READ(current_task, tgid);                                   \
      event->module##_event_t.process.ppid =                                   \
          BPF_CORE_READ(current_task, real_parent, pid);                       \
      event->module##_event_t.process.start =                                  \
          adjust_timestamp(BPF_CORE_READ(current_task, start_time));           \
      BPF_CORE_READ_INTO(&event->module##_event_t.process.name, current_task,  \
                         comm);                                                \
      /* blocked on d_path resolution for executable name by                   \
       * https://lwn.net/Articles/827938/ essentially d_path of                \
       * current_task->mm->exe_file->f_path kernel 5.11 */                     \
                                                                               \
      event->module##_event_t.process.parent.pid =                             \
          BPF_CORE_READ(current_task, real_parent, pid);                       \
      event->module##_event_t.process.parent.thread__id =                      \
          BPF_CORE_READ(current_task, real_parent, tgid);                      \
      event->module##_event_t.process.parent.ppid =                            \
          BPF_CORE_READ(current_task, real_parent, real_parent, pid);          \
      event->module##_event_t.process.parent.start = adjust_timestamp(         \
          BPF_CORE_READ(current_task, real_parent, start_time));               \
      BPF_CORE_READ_INTO(&event->module##_event_t.process.parent.name,         \
                         current_task, real_parent, comm);                     \
      /* blocked on d_path resolution for executable name by                   \
       * https://lwn.net/Articles/827938/ essentially d_path of                \
       * current_task->real_parent->mm->exe_file->f_path  kernel 5.11 */       \
                                                                               \
      event->module##_event_t.user.id =                                        \
          BPF_CORE_READ(current_task, real_cred, uid.val);                     \
      event->module##_event_t.user.group.id =                                  \
          BPF_CORE_READ(current_task, real_cred, gid.val);                     \
      event->module##_event_t.user.effective.id =                              \
          BPF_CORE_READ(current_task, cred, uid.val);                          \
      event->module##_event_t.user.effective.group.id =                        \
          BPF_CORE_READ(current_task, cred, gid.val);                          \
      __ret = ____##module(___bpf_ctx_cast(args), &event->module##_event_t,    \
                           current_task);                                      \
      const char denied[] = "" #prefix "-denied";                              \
      const char allowed[] = "" #prefix "-allowed";                            \
      if (__ret == 0) { /* don't override what the user has set */             \
        unsigned int index = module##_index;                                   \
        unsigned int *size =                                                   \
            bpf_map_lookup_elem(&rejection_rule_sizes, &index);                \
        if (size && *size > 0) {                                               \
          if (___check_##module(*size, &module##_rejections,                   \
                                &event->module##_event_t)) {                   \
            SET_STRING(event->module##_event_t.event.action, denied);          \
            __ret = -EPERM;                                                    \
          } else {                                                             \
            SET_STRING(event->module##_event_t.event.action, allowed);         \
          }                                                                    \
        } else {                                                               \
          SET_STRING(event->module##_event_t.event.action, allowed);           \
        }                                                                      \
      } else {                                                                 \
        SET_STRING(event->module##_event_t.event.action, allowed);             \
      }                                                                        \
    }                                                                          \
    _Pragma("GCC diagnostic pop") if (event)                                   \
        bpf_ringbuf_submit(event, RINGBUFFER_FLAGS);                           \
    return __ret;                                                              \
  }                                                                            \
  static int ____##module(unsigned long long *ctx, ##args,                     \
                          struct bpf_##module##_event_t *event,                \
                          struct task_struct *current_task)

#define initialize_event()                                                     \
  if (!event)                                                                  \
    return 0;
#define reject(event) return -EPERM
#define submit(event) return 0

#define get_tracepoint_event(name) __get_tracepoint_event(current_task, (struct bpf_map *)&name##_events)
#define delete_tracepoint_event(name) __delete_tracepoint_event(current_task, (struct bpf_map *)&name##_events)

__attribute__((always_inline)) static void *
__get_tracepoint_event(struct task_struct *current_task, struct bpf_map *map) {
  pid_t pid = BPF_CORE_READ(current_task, pid);
  return bpf_map_lookup_elem(map, &pid);
}

__attribute__((always_inline)) static void __delete_tracepoint_event(struct task_struct *current_task, struct bpf_map *map) {
  pid_t pid = BPF_CORE_READ(current_task, pid);
  bpf_map_delete_elem(map, &pid);
}

const volatile unsigned long clock_adjustment = 0;

__attribute__((always_inline)) static unsigned long
adjust_timestamp(unsigned long timestamp) {
  return (timestamp + clock_adjustment) / 1000000000l;
}

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 256 * 1024);
} events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(u32));
  __uint(max_entries, {{ modules | length }});
} filter_rule_sizes SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(u32));
  __uint(max_entries, {{ modules | length }});
} rejection_rule_sizes SEC(".maps");

{% for module in modules %}
const volatile unsigned char {{module.name}}_enabled = 0;

{% set entry_point = module.structures | last %}
{% if entry_point.queryable %}
__attribute__((always_inline)) static int ___test_{{module.name}}(
  struct bpf_{{entry_point.name}} *event,
  struct query_bpf_{{entry_point.name}} *rule
) {
  int conditional_true = 1;
  if (rule && event) {
    if (rule->___absolute == TRUE_ABSOLUTE) {
      return 1;
    } else if (rule->___absolute == FALSE_ABSOLUTE) {
      return 0;
    } else {
      {% for structure in module.structures -%}
      {% for field in structure.fields -%}
      {% if field.queryable and not field.complex %}
      if (rule->{{field.path}}{{field.name}}___operator == EQUAL_OPERATOR) {
        conditional_true = conditional_true && {{field.queryable | upper }}_EQUALITY(event->{{field.path}}{{field.name}},rule->{{field.path}}{{field.name}});
      } else if (rule->{{field.path}}{{field.name}}___operator == NOT_EQUAL_OPERATOR) {
        conditional_true = conditional_true && {{field.queryable | upper }}_INEQUALITY(event->{{field.path}}{{field.name}}, rule->{{field.path}}{{field.name}});
      }
      {% endif -%}
      {%- endfor -%}
      {%- endfor -%}
    }
  }

  return conditional_true;
}

__attribute__((always_inline)) static int ___check_{{module.name}}(
  unsigned int size,
  void *rule_map,
  struct bpf_{{entry_point.name}} *event
) {
  int conditional_true = 0;
  if (!rule_map) return conditional_true;
  #pragma unroll
  for (int i = 0; i < MAX_RULE_SIZE; i++) {
    unsigned int index = i;
    if (index >= size) {
      return conditional_true;
    }
    struct query_bpf_{{entry_point.name}} *rule = bpf_map_lookup_elem(rule_map, &index);
    conditional_true = conditional_true || ___test_{{module.name}}(event, rule);
  }
  return conditional_true;
}

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(struct query_bpf_{{entry_point.name}}));
  __uint(max_entries, 8);
} {{module.name}}_filters SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(struct query_bpf_{{entry_point.name}}));
  __uint(max_entries, 8);
} {{module.name}}_rejections SEC(".maps");
{% endif %}
{%- endfor -%}

{% for tracepoint in tracepoints %}
struct {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 10240);
	__type(key, pid_t);
	__type(value, struct tp_{{tracepoint.hook}}_event);
} {{tracepoint.hook}}_events SEC(".maps");

const struct tp_{{tracepoint.hook}}_event empty_{{tracepoint.hook}}_event = {};
{% endfor %}

char _license[] SEC("license") = "GPL";
#endif

#endif /* __PROBE_BPF_H */
