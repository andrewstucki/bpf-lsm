#!/usr/bin/env python3

from os import path
from glob import glob
from yaml import load, Loader
from typing import Any, NamedTuple
import re
import subprocess

from jinja2 import Template

class Tracepoint(NamedTuple):
  family: str
  hook: str

BPF_MODULES = ["bprm_check_security"]
TRACEPOINTS = [
  ("syscalls", "sys_enter_execve"),
  ("syscalls", "sys_exit_fork"),
  ("syscalls", "sys_exit_vfork"),
  ("syscalls", "sys_exit_clone"),
  ("syscalls", "sys_exit_clone3"),
  ("sched", "sched_process_free"),
]

CURRENT_DIRECTORY = path.dirname(path.realpath(__file__))
SCHEMAS_DIRECTORY = path.abspath(path.join(CURRENT_DIRECTORY, "..", "..", "schemas"))
BPF_SCHEMA_FILES = [path.join(SCHEMAS_DIRECTORY, "%s.yml" % f) for f in BPF_MODULES]

BPF_TEMPLATE = Template(open(path.join(CURRENT_DIRECTORY, "..", "templates", "include", "probe_bpf.generated.h.j2")).read())
BPF_OUTPUT = path.join(CURRENT_DIRECTORY, "..", "src", "include", "probe_bpf.generated.h")

USERSPACE_TEMPLATE = Template(open(path.join(CURRENT_DIRECTORY, "..", "templates", "probe.c.j2")).read())
USERSPACE_OUTPUT = path.join(CURRENT_DIRECTORY, "..", "src", "probe.c")

COMMON_HEADER_TEMPLATE = Template(open(path.join(CURRENT_DIRECTORY, "..", "templates", "include", "probe_common.generated.h.j2")).read())
COMMON_HEADER_OUTPUT = path.join(CURRENT_DIRECTORY, "..", "src", "include", "probe_common.generated.h")

USERSPACE_HEADER_TEMPLATE = Template(open(path.join(CURRENT_DIRECTORY, "..", "templates", "include", "probe.generated.h.j2")).read())
USERSPACE_HEADER_OUTPUT = path.join(CURRENT_DIRECTORY, "..", "src", "include", "probe.generated.h")

RUST_TEMPLATE = Template(open(path.join(CURRENT_DIRECTORY, "..", "templates", "lib.rs.j2")).read())
RUST_OUTPUT = path.join(CURRENT_DIRECTORY, "..", "src", "lib.rs")

COMPILER_TEMPLATE = Template(open(path.join(CURRENT_DIRECTORY, "..", "templates", "compiler.rs.j2")).read())
COMPILER_OUTPUT = path.join(CURRENT_DIRECTORY, "..", "src", "compiler.rs")

PROTO_TEMPLATE = Template(open(path.join(CURRENT_DIRECTORY, "..", "templates", "struct.proto.j2")).read())
PROTO_OUTPUT = path.join(CURRENT_DIRECTORY, "..", "src", "struct.proto")

class FieldType(NamedTuple):
  transformation: Any
  final: str
  proto: str
  rust: str
  name: Any
  size: Any
  lifetime: bool
  setter: Any

class Field(NamedTuple):
  type: FieldType
  enrichment: bool
  final: str
  name: str
  original: str
  complex: bool
  queryable: Any
  path: str

class FieldStructure(NamedTuple):
  final: str
  name: str
  enrichment: bool
  lifetime: bool
  fields: list
  queryable: bool

class ModuleStructures(NamedTuple):
  final: str
  name: str
  structures: list
  map: dict = {}

class Transformation(NamedTuple):
  method: str

BPF_TYPES = {
  'date': FieldType(None, 'u64', 'uint64', 'u64', 'unsigned long', None, False, None),
  'long': FieldType(None, 'u64', 'uint64', 'u64', 'unsigned long', None, False, None),
  'keyword': FieldType(Transformation('transform_string'), 'String', 'string', 'c_char', 'char', 256, False, None),
  'wildcard': FieldType(Transformation('transform_string'), 'String', 'string', 'c_char', 'char', 256, False, None),
}

# add to this as need be
NAME_NORMALIZATION = re.compile(r"[@\.]")
UNDERSCORE_NORMALIZATION = re.compile(r"__")

def normalize_name(name):
  return NAME_NORMALIZATION.sub("__", name)

def rustify(name):
  keywords = ["type"]
  if name in keywords:
    return "field_%s" % name
  if name == "__timestamp":
    return "timestamp"
  return UNDERSCORE_NORMALIZATION.sub("_", name)

def rustify_class(name):
  return ''.join(word.title() for word in name.split('_'))

class Generator:
  def __init__(self, filename):
    with open(filename) as file:
      self.module = path.splitext(path.basename(filename))[0]
      self.data = load(file, Loader=Loader)

  def _structure_name(self, namespaces):
    return "_".join([self.module, "event"] + namespaces + ["t"])

  def _rusty_name(self, namespaces):
    name = "_".join([self.module, "event"] + namespaces)
    return rustify_class(name)

  def _build_structs(self, types, lifetime, enrichment=False, namespaces=[], child=None):
    data = child if child else self.data
    structures = []
    fields = []
    parent_queryable = False
    for field in data:
      field_enrichment = field.get('enrichment', enrichment)
      name = field.get('name')
      field_type = field.get('type')
      normalized_name = normalize_name(name)
      rust_name = rustify(normalized_name)
      complex = False
      queryable = False
      if field_type == 'group':
        complex = True
        child_namespaces = namespaces + [normalized_name]
        child_lifetime = field.get('lifetime', False)
        if child_lifetime:
          lifetime = True
        child_structures = self._build_structs(types, child_lifetime, field_enrichment, child_namespaces, field.get('fields'))
        for c in child_structures:
          if c.queryable:
            queryable = True
            parent_queryable = True
            break
        field_type = FieldType(None, self._rusty_name(child_namespaces), self._rusty_name(child_namespaces), self._structure_name(child_namespaces), self._structure_name(child_namespaces), None, child_lifetime, None)
        structures += child_structures
      else:
        queryable = field.get('queryable', False)
        if queryable:
          parent_queryable = True
        if 'override' in field:
          field_type = FieldType(field['override'].get('transform', None), field['override']['final'], field['override']['proto'], field['override']['rust'], field['override']['c'], None, False, field['override'].get('setter', None))
        else:
          field_type = types[field_type]
      field_path = ".".join(namespaces)
      if len(namespaces) > 0:
        field_path += "."
      fields.append(Field(field_type, field_enrichment, rust_name, normalized_name, name, complex, queryable, field_path))
    structure = FieldStructure(self._rusty_name(namespaces), self._structure_name(namespaces), enrichment, lifetime, fields, parent_queryable)
    structures.append(structure)
    return structures

  def dump_bpf_structs(self):
    return ModuleStructures(rustify_class(self.module), self.module, self._build_structs(BPF_TYPES, False))

  def dump_tracepoint_structs(self):
    return self.data

  def dump(self):
    print(self.module, self.data)

if __name__ == "__main__":
  generators = [Generator(filename) for filename in BPF_SCHEMA_FILES]
  modules = [generator.dump_bpf_structs() for generator in generators]
  tracepoints = [Tracepoint(family, hook) for (family, hook) in TRACEPOINTS]
  with open(BPF_OUTPUT, "w") as bpf_output:
    bpf_output.write(BPF_TEMPLATE.render(modules=modules))
  with open(USERSPACE_OUTPUT, "w") as bpf_output:
    bpf_output.write(USERSPACE_TEMPLATE.render(modules=modules, tracepoints=tracepoints))
  with open(USERSPACE_HEADER_OUTPUT, "w") as bpf_output:
    bpf_output.write(USERSPACE_HEADER_TEMPLATE.render(modules=modules))
  with open(COMMON_HEADER_OUTPUT, "w") as bpf_output:
    bpf_output.write(COMMON_HEADER_TEMPLATE.render(modules=modules))
  with open(RUST_OUTPUT, "w") as bpf_output:
    bpf_output.write(RUST_TEMPLATE.render(modules=modules))
  with open(COMPILER_OUTPUT, "w") as bpf_output:
    bpf_output.write(COMPILER_TEMPLATE.render(modules=modules))
  with open(PROTO_OUTPUT, "w") as bpf_output:
    bpf_output.write(PROTO_TEMPLATE.render(modules=modules))
  subprocess.run(["clang-format", "-i", BPF_OUTPUT], check=True)
  subprocess.run(["clang-format", "-i", USERSPACE_OUTPUT], check=True)
  subprocess.run(["clang-format", "-i", USERSPACE_HEADER_OUTPUT], check=True)
