// Code generated by scripts/generate-structures - DO NOT EDIT.
// to modify, regenerate after modifying templates/probe_bpf.generated.h.j2

// clang-format off

#ifndef __PROBE__GENERATED_H
#define __PROBE__GENERATED_H

#include "probe_common.h"

#define EVENT_HOOKS {{event_hooks}}
#define ALL_HOOKS {{all_hooks}}

{% for module in modules %}
{{ module.render_c(loop.index0) }}
{% endfor %}

enum event_type {
{% for module in modules %}{% set entry_point = module.structures | last %}
  type_{{ entry_point.name }},
{% endfor %}
};

struct bpf_event_t {
  enum event_type type;
  union {
{% for module in modules %}{% set entry_point = module.structures | last %}
    struct bpf_{{entry_point.name}} {{entry_point.name}};
{% endfor %}
  };
};

#ifdef BPF

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(u32));
  __uint(max_entries, {{ modules | length }});
} filter_rule_sizes SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(u32));
  __uint(max_entries, {{ modules | length }});
} rejection_rule_sizes SEC(".maps");

{% for module in modules %}{% set entry_point = module.structures | last %}{% if entry_point.queryable %}
INLINE_STATIC int ___test_{{module.name}}(
  struct bpf_{{entry_point.name}} *event,
  struct query_bpf_{{entry_point.name}} *rule
) {
  int conditional_true = 1;
  if (rule && event) {
    if (rule->___absolute == TRUE_ABSOLUTE) {
      return 1;
    } else if (rule->___absolute == FALSE_ABSOLUTE) {
      return 0;
    } else {
{% for structure in module.structures %}
{% for field in structure.fields %}{% if field.queryable and not field.complex %}
      if (rule->{{field.path}}{{field.name}}___operator == EQUAL_OPERATOR) {
        conditional_true = conditional_true && {{field.queryable | upper }}_EQUALITY(event->{{field.path}}{{field.name}},rule->{{field.path}}{{field.name}});
      } else if (rule->{{field.path}}{{field.name}}___operator == NOT_EQUAL_OPERATOR) {
        conditional_true = conditional_true && {{field.queryable | upper }}_INEQUALITY(event->{{field.path}}{{field.name}}, rule->{{field.path}}{{field.name}});
      }
{% endif %}{% endfor %}
{% endfor %}
    }
  }

  return conditional_true;
}

INLINE_STATIC int ___check_{{module.name}}(
  unsigned int size,
  void *rule_map,
  struct bpf_{{entry_point.name}} *event
) {
  int conditional_true = 0;
  if (!rule_map) return conditional_true;
  #pragma unroll
  for (int i = 0; i < MAX_RULE_SIZE; i++) {
    unsigned int index = i;
    if (index >= size) {
      return conditional_true;
    }
    struct query_bpf_{{entry_point.name}} *rule = bpf_map_lookup_elem(rule_map, &index);
    conditional_true = conditional_true || ___test_{{module.name}}(event, rule);
  }
  return conditional_true;
}

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(struct query_bpf_{{entry_point.name}}));
  __uint(max_entries, 8);
} {{module.name}}_filters SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(struct query_bpf_{{entry_point.name}}));
  __uint(max_entries, 8);
} {{module.name}}_rejections SEC(".maps");
{% endif %}{% endfor %}

#endif

#endif // __PROBE__GENERATED_H

// clang-format on
