// Code generated by scripts/generate-structures - DO NOT EDIT.
// to modify, regenerate after modifying templates/probe_bpf.generated.h.j2

// clang-format off

#ifndef __PROBE__GENERATED_H
#define __PROBE__GENERATED_H

#include "probe_common.h"

#define EVENT_HOOKS bprm_check_security
#define ALL_HOOKS bprm_check_security, sys_enter_execve, sys_exit_fork, sys_exit_vfork, sys_exit_clone, sys_exit_clone3, sched_process_free

#define bprm_check_security_index 0

struct bpf_bprm_check_security_event_event_t {
  char action[256];
};
struct bpf_bprm_check_security_event_process_parent_t {
  unsigned int pid;
  char entity_id[256];
  char name[256];
  unsigned long args_count;
  char args[64][128];
  unsigned int ppid;
  unsigned long start;
  unsigned long thread__id;
  char executable[256];
};
struct bpf_bprm_check_security_event_process_t {
  unsigned int pid;
  char entity_id[256];
  char name[256];
  unsigned int ppid;
  char executable[256];
  unsigned long args_count;
  unsigned long start;
  unsigned long thread__id;
  char args[64][128];
  struct bpf_bprm_check_security_event_process_parent_t parent;
};
struct bpf_bprm_check_security_event_user_group_t {
  unsigned int id;
};
struct bpf_bprm_check_security_event_user_effective_group_t {
  unsigned int id;
};
struct bpf_bprm_check_security_event_user_effective_t {
  unsigned int id;
  struct bpf_bprm_check_security_event_user_effective_group_t group;
};
struct bpf_bprm_check_security_event_user_t {
  unsigned int id;
  struct bpf_bprm_check_security_event_user_group_t group;
  struct bpf_bprm_check_security_event_user_effective_t effective;
};
struct bpf_bprm_check_security_event_t {
  unsigned long __timestamp;
  struct bpf_bprm_check_security_event_event_t event;
  struct bpf_bprm_check_security_event_process_t process;
  struct bpf_bprm_check_security_event_user_t user;
};

struct query_bpf_bprm_check_security_event_process_t {
  char executable___operator;
  char executable[256];
};
struct query_bpf_bprm_check_security_event_user_t {
  char id___operator;
  unsigned int id;
};
struct query_bpf_bprm_check_security_event_t {
  char ___absolute;
  struct query_bpf_bprm_check_security_event_process_t process;
  struct query_bpf_bprm_check_security_event_user_t user;
};

enum event_type {
  type_bprm_check_security_event_t,
};

struct bpf_event_t {
  enum event_type type;
  union {
    struct bpf_bprm_check_security_event_t bprm_check_security_event_t;
  };
};

#ifdef BPF

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(u32));
  __uint(max_entries, 1);
} filter_rule_sizes SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(u32));
  __uint(max_entries, 1);
} rejection_rule_sizes SEC(".maps");

INLINE_STATIC int ___test_bprm_check_security(
  struct bpf_bprm_check_security_event_t *event,
  struct query_bpf_bprm_check_security_event_t *rule
) {
  int conditional_true = 1;
  if (rule && event) {
    if (rule->___absolute == TRUE_ABSOLUTE) {
      return 1;
    } else if (rule->___absolute == FALSE_ABSOLUTE) {
      return 0;
    } else {
      if (rule->process.executable___operator == EQUAL_OPERATOR) {
        conditional_true = conditional_true && STRING_EQUALITY(event->process.executable,rule->process.executable);
      } else if (rule->process.executable___operator == NOT_EQUAL_OPERATOR) {
        conditional_true = conditional_true && STRING_INEQUALITY(event->process.executable, rule->process.executable);
      }
      if (rule->user.id___operator == EQUAL_OPERATOR) {
        conditional_true = conditional_true && NUMBER_EQUALITY(event->user.id,rule->user.id);
      } else if (rule->user.id___operator == NOT_EQUAL_OPERATOR) {
        conditional_true = conditional_true && NUMBER_INEQUALITY(event->user.id, rule->user.id);
      }
    }
  }

  return conditional_true;
}

INLINE_STATIC int ___check_bprm_check_security(
  unsigned int size,
  void *rule_map,
  struct bpf_bprm_check_security_event_t *event
) {
  int conditional_true = 0;
  if (!rule_map) return conditional_true;
  #pragma unroll
  for (int i = 0; i < MAX_RULE_SIZE; i++) {
    unsigned int index = i;
    if (index >= size) {
      return conditional_true;
    }
    struct query_bpf_bprm_check_security_event_t *rule = bpf_map_lookup_elem(rule_map, &index);
    conditional_true = conditional_true || ___test_bprm_check_security(event, rule);
  }
  return conditional_true;
}

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(struct query_bpf_bprm_check_security_event_t));
  __uint(max_entries, 8);
} bprm_check_security_filters SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_ARRAY);
  __uint(key_size, sizeof(u32));
  __uint(value_size, sizeof(struct query_bpf_bprm_check_security_event_t));
  __uint(max_entries, 8);
} bprm_check_security_rejections SEC(".maps");

#endif

#endif // __PROBE__GENERATED_H

// clang-format on